# 99 Dias de Java

:shields-cdn: https://img.shields.io/

:toc:

99 dias de conteúdo Java com o propósito de aprender e praticar! Bora praticar e aprender juntos? :)

Qualquer dúvida, sugestão e críticas, por favor, entre em contato:

image:{shields-cdn}twitter/url?color=%231DA1F2&label=maxdearruda&logo=twitter&logoColor=%231DA1F2&style=flat&url=https%3A%2F%2Ftwitter.com%2Fmaxdearruda[caption="@maxdearruda",link=https://twitter.com/maxdearruda,window=_blank]

== Dia 01 - Modelando com Java: Representando números racionais

[source,java]
----
package noventaenovediasdejava.dia01;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

class NumeroRacionalTest {
    @Test
    void test() {
        Assertions.assertThrows(
            IllegalArgumentException.class,
            () -> new NumeroRacional(1, 0),
            "não deve aceitar denominador igual á 0"
        );
        Assertions.assertThrows(
            IllegalArgumentException.class,
            () -> new NumeroRacional(null, 1),
            "não deve aceitar numerador nulo"
        );
        Assertions.assertThrows(
            IllegalArgumentException.class,
            () -> new NumeroRacional(1, null),
            "não deve aceitar denominador nulo"
        );
    }
}
----
[source,java]
----
package noventaenovediasdejava.dia01;

public record NumeroRacional(Integer numerador, Integer denominador) {
    public NumeroRacional {
        if (numerador == null) {
            throw new IllegalArgumentException("numerador não pode ser nulo");
        }
        if (denominador == null) {
            throw new IllegalArgumentException("denominador não pode ser nulo");
        }
        if (Integer.valueOf(0).equals(denominador)) {
            throw new IllegalArgumentException("denominador não pode ser igual à 0");
        }
    }
}
----
== Dia 02 - Modelando com Java: Sobrescrevendo metódos Java

[source,java]
----
package noventaenovediasdejava.dia02;

public record NumeroRacional(Integer numerador, Integer denominador) {
    public NumeroRacional {
        if (numerador == null) {
            throw new IllegalArgumentException("numerador não pode ser nulo");
        }
        if (denominador == null) {
            throw new IllegalArgumentException("denominador não pode ser nulo");
        }
        if (Integer.valueOf(0).equals(denominador)) {
            throw new IllegalArgumentException("denominador não pode ser igual a 0");
        }
    }

    @Override
    public String toString() {
        return "%s/%s".formatted(this.numerador, this.denominador);
    }

}
----

[source,java]
----
package noventaenovediasdejava.dia02;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

@TestMethodOrder(OrderAnnotation.class)
class NumeroRacionalTest {
    @Test
    @Order(0)
    void testarInstanciacao() {
        Assertions.assertThrows(
            IllegalArgumentException.class,
            () -> new NumeroRacional(1, 0),
            "não deve aceitar denominador igual a 0"
        );
        Assertions.assertThrows(
            IllegalArgumentException.class,
            () -> new NumeroRacional(null, 1),
            "não deve aceitar numerador nulo"
        );
        Assertions.assertThrows(
            IllegalArgumentException.class,
            () -> new NumeroRacional(1, null),
            "não deve aceitar denominador nulo"
        );
    }

    @Test
    @Order(1)
    void testarToString() {
        var numeroRacional = new NumeroRacional(2, 3);
        Assertions.assertEquals("2/3", numeroRacional.toString());
    }
}
----
== Dia 03 - Vamos representar números racionais em sua forma irredutível com Java!

[source,java]
----
package noventaenovediasdejava.dia03;

public record NumeroRacional(Integer numerador, Integer denominador) {
    public NumeroRacional {
        if (numerador == null) {
            throw new IllegalArgumentException("numerador não pode ser nulo");
        }
        if (denominador == null) {
            throw new IllegalArgumentException("denominador não pode ser nulo");
        }
        if (Integer.valueOf(0).equals(denominador)) {
            throw new IllegalArgumentException("denominador não pode ser igual a 0");
        }
    }

    @Override
    public String toString() {
        return "%s/%s".formatted(this.numerador, this.denominador);
    }

    public NumeroRacional formaIrredutivel() {
        int numero = Math.abs(this.numerador);
        int maximoDivisorComum = Math.abs(this.denominador);
        int resto = 0;
        do {
            if (resto != 0) {
                numero = maximoDivisorComum;
                maximoDivisorComum = resto;
            }
            resto = numero % maximoDivisorComum;
        } while (resto != 0);
        return new NumeroRacional(
            this.numerador / maximoDivisorComum,
            this.denominador / maximoDivisorComum
        );
    }
}
----

[source,java]
----
package noventaenovediasdejava.dia03;

import java.util.stream.Stream;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

@TestMethodOrder(OrderAnnotation.class)
class NumeroRacionalTest {
    @Test
    @Order(0)
    void testarInstanciacao() {
        Assertions.assertThrows(
            IllegalArgumentException.class,
            () -> new NumeroRacional(1, 0),
            "não deve aceitar denominador igual a 0"
        );
        Assertions.assertThrows(
            IllegalArgumentException.class,
            () -> new NumeroRacional(null, 1),
            "não deve aceitar numerador nulo"
        );
        Assertions.assertThrows(
            IllegalArgumentException.class,
            () -> new NumeroRacional(1, null),
            "não deve aceitar denominador nulo"
        );
    }

    @Test
    @Order(1)
    void testarToString() {
        var numeroRacional = new NumeroRacional(2, 3);
        Assertions.assertEquals("2/3", numeroRacional.toString());
    }

    @ParameterizedTest(name = "[{index}] a forma irredutível de {0} deve ser igual a {1}")
    @MethodSource("testarFormaIrredutivelArgs")
    void testarFormaIrredutivel(
        final NumeroRacional numeroRacionalBase,
        final NumeroRacional numeroRacionalNaFormaIrredutivelEsperado
    ) {
        final NumeroRacional numeroRacionalNaFormaIrredutivel = numeroRacionalBase
            .formaIrredutivel();
        Assertions.assertNotNull(
            numeroRacionalNaFormaIrredutivel,
            "não deve ser retornado valor/referência nulo"
        );
        Assertions.assertEquals(
            numeroRacionalNaFormaIrredutivelEsperado,
            numeroRacionalNaFormaIrredutivel
        );
    }

    static Stream<Arguments> testarFormaIrredutivelArgs() {
        return Stream.of(
            Arguments.arguments(
                new NumeroRacional(12,4),
                new NumeroRacional(3,1)
            ),
            Arguments.arguments(
                new NumeroRacional(130,78),
                new NumeroRacional(5,3)
            ),
            Arguments.arguments(
                new NumeroRacional(-130,78),
                new NumeroRacional(-5,3)
            ),
            Arguments.arguments(
                new NumeroRacional(130,-78),
                new NumeroRacional(5,-3)
            )
        );
    }
}
----
== Dia 04 - Somando números racionais com Java!

[source,java]
----
package noventaenovediasdejava.dia04;

public record NumeroRacional(Integer numerador, Integer denominador) {
    public NumeroRacional {
        if (numerador == null) {
            throw new IllegalArgumentException("numerador não pode ser nulo");
        }
        if (denominador == null) {
            throw new IllegalArgumentException("denominador não pode ser nulo");
        }
        if (Integer.valueOf(0).equals(denominador)) {
            throw new IllegalArgumentException("denominador não pode ser igual a 0");
        }
    }

    @Override
    public String toString() {
        return "%s/%s".formatted(this.numerador, this.denominador);
    }

    public NumeroRacional formaIrredutivel() {
        int numero = Math.abs(this.numerador);
        int maximoDivisorComum = Math.abs(this.denominador);
        int resto = 0;
        do {
            if (resto != 0) {
                numero = maximoDivisorComum;
                maximoDivisorComum = resto;
            }
            resto = numero % maximoDivisorComum;
        } while (resto != 0);
        return new NumeroRacional(
            this.numerador / maximoDivisorComum,
            this.denominador / maximoDivisorComum
        );
    }

    public NumeroRacional somar(final NumeroRacional numeroRacional) {
        //        N1   N2   N1*D2+N2*D1
        //        -- + -- = ----------- =
        //        D1   D2     D1 * D2
        int n1 = this.numerador;
        int d1 = this.denominador;
        int n2 = numeroRacional.numerador;
        int d2 = numeroRacional.denominador;
        final NumeroRacional resultado =
            new NumeroRacional(
                ((n1 * d2) + (n2 * d1)),
                (d1 * d2)
            );
        return resultado.formaIrredutivel();
    }
}
----
[source,java]
----
package noventaenovediasdejava.dia04;

import java.util.stream.Stream;
import noventaenovediasdejava.dia04.NumeroRacional;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

@TestMethodOrder(OrderAnnotation.class)
class NumeroRacionalTest {
    @Test
    @Order(0)
    void testarInstanciacao() {
        Assertions.assertThrows(
            IllegalArgumentException.class,
            () -> new NumeroRacional(1, 0),
            "não deve aceitar denominador igual a 0"
        );
        Assertions.assertThrows(
            IllegalArgumentException.class,
            () -> new NumeroRacional(null, 1),
            "não deve aceitar numerador nulo"
        );
        Assertions.assertThrows(
            IllegalArgumentException.class,
            () -> new NumeroRacional(1, null),
            "não deve aceitar denominador nulo"
        );
    }

    @Test
    @Order(1)
    void testarToString() {
        var numeroRacional = new NumeroRacional(2, 3);
        Assertions.assertEquals("2/3", numeroRacional.toString());
    }

    @ParameterizedTest(name = "[{index}] a forma irredutível de {0} deve ser igual a {1}")
    @MethodSource("testarFormaIrredutivelArgs")
    void testarFormaIrredutivel(
        final NumeroRacional numeroRacionalBase,
        final NumeroRacional numeroRacionalNaFormaIrredutivelEsperado
    ) {
        final NumeroRacional numeroRacionalNaFormaIrredutivel = numeroRacionalBase
            .formaIrredutivel();
        Assertions.assertNotNull(
            numeroRacionalNaFormaIrredutivel,
            "não deve ser retornado valor/referência nulo"
        );
        Assertions.assertEquals(
            numeroRacionalNaFormaIrredutivelEsperado,
            numeroRacionalNaFormaIrredutivel
        );
    }

    static Stream<Arguments> testarFormaIrredutivelArgs() {
        return Stream.of(
            Arguments.arguments(
                new NumeroRacional(12, 4),
                new NumeroRacional(3, 1)
            ),
            Arguments.arguments(
                new NumeroRacional(130, 78),
                new NumeroRacional(5, 3)
            ),
            Arguments.arguments(
                new NumeroRacional(-130, 78),
                new NumeroRacional(-5, 3)
            ),
            Arguments.arguments(
                new NumeroRacional(130, -78),
                new NumeroRacional(5, -3)
            )
        );
    }

    @ParameterizedTest(name = "[{index}] {0} + {1} = {2}")
    @MethodSource("testarSomarArgs")
    void testarSomar(
        final NumeroRacional numeroRacional01,
        final NumeroRacional numeroRacional02,
        final NumeroRacional resultadoEsperado
    ) {
        final NumeroRacional resultadoAtual =
            numeroRacional01.somar(numeroRacional02);
        Assertions.
            assertNotNull(resultadoAtual,
                          "não deve retornar valor/referência nula");
        Assertions.
            assertEquals(
                resultadoEsperado,
                resultadoAtual
            );
    }

    static Stream<Arguments> testarSomarArgs() {
        return Stream.of(
            Arguments.arguments(
                new NumeroRacional(1, 4),
                new NumeroRacional(1, 4),
                new NumeroRacional(1, 2)
            ),
            Arguments.arguments(
                new NumeroRacional(2, 3),
                new NumeroRacional(3, 4),
                new NumeroRacional(17, 12)
            ),
            Arguments.arguments(
                new NumeroRacional(5, 3),
                new NumeroRacional(4, 12),
                new NumeroRacional(2, 1)
            )
        );
    }
}
----
== Dia 05 - Modelando com Java: Representando números racionais

[source,java]
----
package noventaenovediasdejava.dia05;

public record NumeroRacional(Integer numerador, Integer denominador) {
    public NumeroRacional {
        if (numerador == null) {
            throw new IllegalArgumentException("numerador não pode ser nulo");
        }
        if (denominador == null) {
            throw new IllegalArgumentException("denominador não pode ser nulo");
        }
        if (Integer.valueOf(0).equals(denominador)) {
            throw new IllegalArgumentException("denominador não pode ser igual a 0");
        }
    }

    @Override
    public String toString() {
        return "%s/%s".formatted(this.numerador, this.denominador);
    }

    public NumeroRacional formaIrredutivel() {
        int numero = Math.abs(this.numerador);
        int maximoDivisorComum = Math.abs(this.denominador);
        int resto = 0;
        do {
            if (resto != 0) {
                numero = maximoDivisorComum;
                maximoDivisorComum = resto;
            }
            resto = numero % maximoDivisorComum;
        } while (resto != 0);
        return new NumeroRacional(
            this.numerador / maximoDivisorComum,
            this.denominador / maximoDivisorComum
        );
    }

    public NumeroRacional somar(final NumeroRacional numeroRacional) {
        //        N1   N2   N1*D2+N2*D1
        //        -- + -- = ----------- =
        //        D1   D2     D1 * D2
        int n1 = this.numerador;
        int d1 = this.denominador;
        int n2 = numeroRacional.numerador;
        int d2 = numeroRacional.denominador;
        final NumeroRacional resultado =
            new NumeroRacional(
                ((n1 * d2) + (n2 * d1)),
                (d1 * d2)
            );
        return resultado.formaIrredutivel();
    }

    public NumeroRacional subtrair(final NumeroRacional numeroRacional) {
//        N1   N2   N1*D2-N2*D1
//        -- - -- = ----------- =
//        D1   D2     D1 * D2
        int n1=this.numerador;
        int d1=this.denominador;
        int n2=numeroRacional.numerador;
        int d2=numeroRacional.denominador;

        final NumeroRacional resultado =
            new NumeroRacional(
                (n1*d2 - n2*d1),
                (d1 * d2)
            );
        return resultado.formaIrredutivel();
    }
}
----
[source,java]
----
package noventaenovediasdejava.dia05;

import java.util.stream.Stream;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

@TestMethodOrder(OrderAnnotation.class)
class NumeroRacionalTest {
    @Test
    @Order(0)
    void testarInstanciacao() {
        Assertions.assertThrows(
            IllegalArgumentException.class,
            () -> new NumeroRacional(1, 0),
            "não deve aceitar denominador igual a 0"
        );
        Assertions.assertThrows(
            IllegalArgumentException.class,
            () -> new NumeroRacional(null, 1),
            "não deve aceitar numerador nulo"
        );
        Assertions.assertThrows(
            IllegalArgumentException.class,
            () -> new NumeroRacional(1, null),
            "não deve aceitar denominador nulo"
        );
    }

    @Test
    @Order(1)
    void testarToString() {
        var numeroRacional = new NumeroRacional(2, 3);
        Assertions.assertEquals("2/3", numeroRacional.toString());
    }

    @ParameterizedTest(name = "[{index}] a forma irredutível de {0} deve ser igual a {1}")
    @MethodSource("testarFormaIrredutivelArgs")
    void testarFormaIrredutivel(
        final NumeroRacional numeroRacionalBase,
        final NumeroRacional numeroRacionalNaFormaIrredutivelEsperado
    ) {
        final NumeroRacional numeroRacionalNaFormaIrredutivel = numeroRacionalBase
            .formaIrredutivel();
        Assertions.assertNotNull(
            numeroRacionalNaFormaIrredutivel,
            "não deve ser retornado valor/referência nulo"
        );
        Assertions.assertEquals(
            numeroRacionalNaFormaIrredutivelEsperado,
            numeroRacionalNaFormaIrredutivel
        );
    }

    static Stream<Arguments> testarFormaIrredutivelArgs() {
        return Stream.of(
            Arguments.arguments(
                new NumeroRacional(12, 4),
                new NumeroRacional(3, 1)
            ),
            Arguments.arguments(
                new NumeroRacional(130, 78),
                new NumeroRacional(5, 3)
            ),
            Arguments.arguments(
                new NumeroRacional(-130, 78),
                new NumeroRacional(-5, 3)
            ),
            Arguments.arguments(
                new NumeroRacional(130, -78),
                new NumeroRacional(5, -3)
            )
        );
    }

    @ParameterizedTest(name = "[{index}] {0} + {1} = {2}")
    @MethodSource("testarSomarArgs")
    void testarSomar(
        final NumeroRacional numeroRacional01,
        final NumeroRacional numeroRacional02,
        final NumeroRacional resultadoEsperado
    ) {
        final NumeroRacional resultadoAtual =
            numeroRacional01.somar(numeroRacional02);
        Assertions.
            assertNotNull(resultadoAtual,
                          "não deve retornar valor/referência nula");
        Assertions.
            assertEquals(
                resultadoEsperado,
                resultadoAtual
            );
    }

    static Stream<Arguments> testarSomarArgs() {
        return Stream.of(
            Arguments.arguments(
                new NumeroRacional(1, 4),
                new NumeroRacional(1, 4),
                new NumeroRacional(1, 2)
            ),
            Arguments.arguments(
                new NumeroRacional(2, 3),
                new NumeroRacional(3, 4),
                new NumeroRacional(17, 12)
            ),
            Arguments.arguments(
                new NumeroRacional(5, 3),
                new NumeroRacional(4, 12),
                new NumeroRacional(2, 1)
            )
        );
    }

    @ParameterizedTest(name = "[{index}] {0} - {1} = {2}")
    @MethodSource("testarSubtrairArgs")
    void testarSubtrair(
        final NumeroRacional numeroRacional01,
        final NumeroRacional numeroRacional02,
        final NumeroRacional resultadoEsperado
    ){
        Assertions.assertEquals(
            resultadoEsperado,
            numeroRacional01.subtrair(numeroRacional02)
        );
    }

    static Stream<Arguments> testarSubtrairArgs(){
        return Stream.of(
            Arguments.arguments(
                new NumeroRacional(1,2),
                new NumeroRacional(3,4),
                new NumeroRacional(-1, 4)
            )
        );
    }

}
----
== Dia 06 - Multiplicando nossas opções: Multiplicação entre números racionais com Java!

[source,java]
----
package noventaenovediasdejava.dia06;

public record NumeroRacional(Integer numerador, Integer denominador) {
    public NumeroRacional {
        if (numerador == null) {
            throw new IllegalArgumentException("numerador não pode ser nulo");
        }
        if (denominador == null) {
            throw new IllegalArgumentException("denominador não pode ser nulo");
        }
        if (Integer.valueOf(0).equals(denominador)) {
            throw new IllegalArgumentException("denominador não pode ser igual a 0");
        }
    }

    @Override
    public String toString() {
        return "%s/%s".formatted(this.numerador, this.denominador);
    }

    public NumeroRacional formaIrredutivel() {
        int numero = Math.abs(this.numerador);
        int maximoDivisorComum = Math.abs(this.denominador);
        int resto = 0;
        do {
            if (resto != 0) {
                numero = maximoDivisorComum;
                maximoDivisorComum = resto;
            }
            resto = numero % maximoDivisorComum;
        } while (resto != 0);
        return new NumeroRacional(
            this.numerador / maximoDivisorComum,
            this.denominador / maximoDivisorComum
        );
    }

    public NumeroRacional somar(final NumeroRacional numeroRacional) {
        //        N1   N2   N1*D2+N2*D1
        //        -- + -- = ----------- =
        //        D1   D2     D1 * D2
        int n1 = this.numerador;
        int d1 = this.denominador;
        int n2 = numeroRacional.numerador;
        int d2 = numeroRacional.denominador;
        final NumeroRacional resultado =
            new NumeroRacional(
                ((n1 * d2) + (n2 * d1)),
                (d1 * d2)
            );
        return resultado.formaIrredutivel();
    }

    public NumeroRacional subtrair(final NumeroRacional numeroRacional) {
//        N1   N2   N1*D2-N2*D1
//        -- - -- = ----------- =
//        D1   D2     D1 * D2
        int n1=this.numerador;
        int d1=this.denominador;
        int n2=numeroRacional.numerador;
        int d2=numeroRacional.denominador;

        final NumeroRacional resultado =
            new NumeroRacional(
                (n1*d2 - n2*d1),
                (d1 * d2)
            );
        return resultado.formaIrredutivel();
    }

    public NumeroRacional multiplicar(
        final NumeroRacional numeroRacional
    ) {
        // (N1 * N2) / (D1 * D2)
        NumeroRacional resultado =
            new NumeroRacional(
                this.numerador * numeroRacional.numerador,
                this.denominador * numeroRacional.denominador
            );
        return resultado.formaIrredutivel();
    }
}
----
[source,java]
----
package noventaenovediasdejava.dia06;

import java.util.stream.Stream;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

@TestMethodOrder(OrderAnnotation.class)
class NumeroRacionalTest {

    @Test
    @Order(0)
    void testarInstanciacao() {
        Assertions.assertThrows(
            IllegalArgumentException.class,
            () -> new NumeroRacional(1, 0),
            "não deve aceitar denominador igual a 0"
        );
        Assertions.assertThrows(
            IllegalArgumentException.class,
            () -> new NumeroRacional(null, 1),
            "não deve aceitar numerador nulo"
        );
        Assertions.assertThrows(
            IllegalArgumentException.class,
            () -> new NumeroRacional(1, null),
            "não deve aceitar denominador nulo"
        );
    }

    @Test
    @Order(1)
    void testarToString() {
        var numeroRacional = new NumeroRacional(2, 3);
        Assertions.assertEquals("2/3", numeroRacional.toString());
    }

    @ParameterizedTest(name = "[{index}] a forma irredutível de {0} deve ser igual a {1}")
    @MethodSource("testarFormaIrredutivelArgs")
    void testarFormaIrredutivel(
        final NumeroRacional numeroRacionalBase,
        final NumeroRacional numeroRacionalNaFormaIrredutivelEsperado
    ) {
        final NumeroRacional numeroRacionalNaFormaIrredutivel = numeroRacionalBase
            .formaIrredutivel();
        Assertions.assertNotNull(
            numeroRacionalNaFormaIrredutivel,
            "não deve ser retornado valor/referência nulo"
        );
        Assertions.assertEquals(
            numeroRacionalNaFormaIrredutivelEsperado,
            numeroRacionalNaFormaIrredutivel
        );
    }

    static Stream<Arguments> testarFormaIrredutivelArgs() {
        return Stream.of(
            Arguments.arguments(
                new NumeroRacional(12, 4),
                new NumeroRacional(3, 1)
            ),
            Arguments.arguments(
                new NumeroRacional(130, 78),
                new NumeroRacional(5, 3)
            ),
            Arguments.arguments(
                new NumeroRacional(-130, 78),
                new NumeroRacional(-5, 3)
            ),
            Arguments.arguments(
                new NumeroRacional(130, -78),
                new NumeroRacional(5, -3)
            )
        );
    }

    @ParameterizedTest(name = "[{index}] {0} + {1} = {2}")
    @MethodSource("testarSomarArgs")
    void testarSomar(
        final NumeroRacional numeroRacional01,
        final NumeroRacional numeroRacional02,
        final NumeroRacional resultadoEsperado
    ) {
        final NumeroRacional resultadoAtual =
            numeroRacional01.somar(numeroRacional02);
        Assertions.
            assertNotNull(
                resultadoAtual,
                "não deve retornar valor/referência nula"
            );
        Assertions.
            assertEquals(
                resultadoEsperado,
                resultadoAtual
            );
    }

    static Stream<Arguments> testarSomarArgs() {
        return Stream.of(
            Arguments.arguments(
                new NumeroRacional(1, 4),
                new NumeroRacional(1, 4),
                new NumeroRacional(1, 2)
            ),
            Arguments.arguments(
                new NumeroRacional(2, 3),
                new NumeroRacional(3, 4),
                new NumeroRacional(17, 12)
            ),
            Arguments.arguments(
                new NumeroRacional(5, 3),
                new NumeroRacional(4, 12),
                new NumeroRacional(2, 1)
            )
        );
    }

    @ParameterizedTest(name = "[{index}] {0} - {1} = {2}")
    @MethodSource("testarSubtrairArgs")
    void testarSubtrair(
        final NumeroRacional numeroRacional01,
        final NumeroRacional numeroRacional02,
        final NumeroRacional resultadoEsperado
    ) {
        Assertions.assertEquals(
            resultadoEsperado,
            numeroRacional01.subtrair(numeroRacional02)
        );
    }

    static Stream<Arguments> testarSubtrairArgs() {
        return Stream.of(
            Arguments.arguments(
                new NumeroRacional(1, 2),
                new NumeroRacional(3, 4),
                new NumeroRacional(-1, 4)
            )
        );
    }

    @ParameterizedTest(name = "[{index}]{0} * {1} = {2}")
    @MethodSource("testarMultiplicacaoArgs")
    void testarMultiplicacao(
        final NumeroRacional numeroRacional01,
        final NumeroRacional numeroRacional02,
        final NumeroRacional resultadoEsperado
    ){
        Assertions
            .assertEquals(resultadoEsperado,
                          numeroRacional01.multiplicar(numeroRacional02)
            );
    }

    static Stream<Arguments> testarMultiplicacaoArgs(){
        return Stream.of(
          Arguments.arguments(
              new NumeroRacional(2,3),
              new NumeroRacional(6,6),
              new NumeroRacional(2,3)
          )
        );
    }

}
----
== Dia 07 - Dividir para conquistar: Divisão entre números racionais com Java!

[source,java]
----
package noventaenovediasdejava.dia07;

public record NumeroRacional(Integer numerador, Integer denominador) {
    public NumeroRacional {
        if (numerador == null) {
            throw new IllegalArgumentException("numerador não pode ser nulo");
        }
        if (denominador == null) {
            throw new IllegalArgumentException("denominador não pode ser nulo");
        }
        if (Integer.valueOf(0).equals(denominador)) {
            throw new IllegalArgumentException("denominador não pode ser igual a 0");
        }
    }

    @Override
    public String toString() {
        return "%s/%s".formatted(this.numerador, this.denominador);
    }

    public NumeroRacional formaIrredutivel() {
        int numero = Math.abs(this.numerador);
        int maximoDivisorComum = Math.abs(this.denominador);
        int resto = 0;
        do {
            if (resto != 0) {
                numero = maximoDivisorComum;
                maximoDivisorComum = resto;
            }
            resto = numero % maximoDivisorComum;
        } while (resto != 0);
        return new NumeroRacional(
            this.numerador / maximoDivisorComum,
            this.denominador / maximoDivisorComum
        );
    }

    public NumeroRacional somar(final NumeroRacional numeroRacional) {
        //        N1   N2   N1*D2+N2*D1
        //        -- + -- = ----------- =
        //        D1   D2     D1 * D2
        int n1 = this.numerador;
        int d1 = this.denominador;
        int n2 = numeroRacional.numerador;
        int d2 = numeroRacional.denominador;
        final NumeroRacional resultado =
            new NumeroRacional(
                ((n1 * d2) + (n2 * d1)),
                (d1 * d2)
            );
        return resultado.formaIrredutivel();
    }

    public NumeroRacional subtrair(final NumeroRacional numeroRacional) {
        //        N1   N2   N1*D2-N2*D1
        //        -- - -- = ----------- =
        //        D1   D2     D1 * D2
        int n1 = this.numerador;
        int d1 = this.denominador;
        int n2 = numeroRacional.numerador;
        int d2 = numeroRacional.denominador;
        final NumeroRacional resultado =
            new NumeroRacional(
                (n1 * d2 - n2 * d1),
                (d1 * d2)
            );
        return resultado.formaIrredutivel();
    }

    public NumeroRacional multiplicar(
        final NumeroRacional numeroRacional
    ) {
        // (N1 * N2) / (D1 * D2)
        NumeroRacional resultado =
            new NumeroRacional(
                this.numerador * numeroRacional.numerador,
                this.denominador * numeroRacional.denominador
            );
        return resultado.formaIrredutivel();
    }

    public NumeroRacional dividir(final NumeroRacional numeroRacional) {
        // (N1*D2)/(N2*D1)
        NumeroRacional resultado =
            new NumeroRacional(
                this.numerador * numeroRacional.denominador,
                numeroRacional.numerador * this.denominador
            );
        return resultado.formaIrredutivel();
    }
}
----
[source, java]
----
package noventaenovediasdejava.dia07;

import java.util.stream.Stream;
import noventaenovediasdejava.dia07.NumeroRacional;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

@TestMethodOrder(OrderAnnotation.class)
class NumeroRacionalTest {
    @Test
    @Order(0)
    void testarInstanciacao() {
        Assertions.assertThrows(
            IllegalArgumentException.class,
            () -> new NumeroRacional(1, 0),
            "não deve aceitar denominador igual a 0"
        );
        Assertions.assertThrows(
            IllegalArgumentException.class,
            () -> new NumeroRacional(null, 1),
            "não deve aceitar numerador nulo"
        );
        Assertions.assertThrows(
            IllegalArgumentException.class,
            () -> new NumeroRacional(1, null),
            "não deve aceitar denominador nulo"
        );
    }

    @Test
    @Order(1)
    void testarToString() {
        var numeroRacional = new NumeroRacional(2, 3);
        Assertions.assertEquals("2/3", numeroRacional.toString());
    }

    @ParameterizedTest(name = "[{index}] a forma irredutível de {0} deve ser igual a {1}")
    @MethodSource("testarFormaIrredutivelArgs")
    void testarFormaIrredutivel(
        final NumeroRacional numeroRacionalBase,
        final NumeroRacional numeroRacionalNaFormaIrredutivelEsperado
    ) {
        final NumeroRacional numeroRacionalNaFormaIrredutivel = numeroRacionalBase
            .formaIrredutivel();
        Assertions.assertNotNull(
            numeroRacionalNaFormaIrredutivel,
            "não deve ser retornado valor/referência nulo"
        );
        Assertions.assertEquals(
            numeroRacionalNaFormaIrredutivelEsperado,
            numeroRacionalNaFormaIrredutivel
        );
    }

    static Stream<Arguments> testarFormaIrredutivelArgs() {
        return Stream.of(
            Arguments.arguments(
                new NumeroRacional(12, 4),
                new NumeroRacional(3, 1)
            ),
            Arguments.arguments(
                new NumeroRacional(130, 78),
                new NumeroRacional(5, 3)
            ),
            Arguments.arguments(
                new NumeroRacional(-130, 78),
                new NumeroRacional(-5, 3)
            ),
            Arguments.arguments(
                new NumeroRacional(130, -78),
                new NumeroRacional(5, -3)
            )
        );
    }

    @ParameterizedTest(name = "[{index}] {0} + {1} = {2}")
    @MethodSource("testarSomarArgs")
    void testarSomar(
        final NumeroRacional numeroRacional01,
        final NumeroRacional numeroRacional02,
        final NumeroRacional resultadoEsperado
    ) {
        final NumeroRacional resultadoAtual =
            numeroRacional01.somar(numeroRacional02);
        Assertions.
            assertNotNull(
                resultadoAtual,
                "não deve retornar valor/referência nula"
            );
        Assertions.
            assertEquals(
                resultadoEsperado,
                resultadoAtual
            );
    }

    static Stream<Arguments> testarSomarArgs() {
        return Stream.of(
            Arguments.arguments(
                new NumeroRacional(1, 4),
                new NumeroRacional(1, 4),
                new NumeroRacional(1, 2)
            ),
            Arguments.arguments(
                new NumeroRacional(2, 3),
                new NumeroRacional(3, 4),
                new NumeroRacional(17, 12)
            ),
            Arguments.arguments(
                new NumeroRacional(5, 3),
                new NumeroRacional(4, 12),
                new NumeroRacional(2, 1)
            )
        );
    }

    @ParameterizedTest(name = "[{index}] {0} - {1} = {2}")
    @MethodSource("testarSubtrairArgs")
    void testarSubtrair(
        final NumeroRacional numeroRacional01,
        final NumeroRacional numeroRacional02,
        final NumeroRacional resultadoEsperado
    ) {
        Assertions.assertEquals(
            resultadoEsperado,
            numeroRacional01.subtrair(numeroRacional02)
        );
    }

    static Stream<Arguments> testarSubtrairArgs() {
        return Stream.of(
            Arguments.arguments(
                new NumeroRacional(1, 2),
                new NumeroRacional(3, 4),
                new NumeroRacional(-1, 4)
            )
        );
    }

    @ParameterizedTest(name = "[{index}]{0} * {1} = {2}")
    @MethodSource("testarMultiplicacaoArgs")
    void testarMultiplicacao(
        final NumeroRacional numeroRacional01,
        final NumeroRacional numeroRacional02,
        final NumeroRacional resultadoEsperado
    ) {
        Assertions
            .assertEquals(
                resultadoEsperado,
                numeroRacional01.multiplicar(numeroRacional02)
            );
    }

    static Stream<Arguments> testarMultiplicacaoArgs() {
        return Stream.of(
            Arguments.arguments(
                new NumeroRacional(2, 3),
                new NumeroRacional(6, 6),
                new NumeroRacional(2, 3)
            )
        );
    }

    @ParameterizedTest(name = "[{index}] {0} / {1} = {2}")
    @MethodSource("testarDividirArgs")
    void testarDividir(
        final NumeroRacional numeroRacional01,
        final NumeroRacional numeroRacional02,
        final NumeroRacional resultadoEsperado
    ) {
        Assertions.assertEquals(
            resultadoEsperado,
            numeroRacional01.dividir(numeroRacional02)
        );
    }

    static Stream<Arguments> testarDividirArgs() {
        return Stream.of(
            Arguments.arguments(
                new NumeroRacional(1, 2),
                new NumeroRacional(3, 4),
                new NumeroRacional(2, 3)
            )
        );
    }
}
----
== Dia 08 - Jokenpô em Java!?

[source,java]
----
package noventaenovediasdejava.dia08;

public interface JogadorJokenpo {
}
----
[source,java]
----
package noventaenovediasdejava.dia08;

public class JogoJokenpo {
    public JogoJokenpo(
        final JogadorJokenpo jogador01,
        final JogadorJokenpo jogador02
    ) {
        if (jogador01 == null && jogador02 == null) {
            throw new IllegalArgumentException("jogadores não informados");
        }
        if (jogador01 != null && jogador02 == null) {
            throw new IllegalArgumentException("jogador 02 não informado");
        }
        if (jogador01 == null && jogador02 != null) {
            throw new IllegalArgumentException("jogador 01 não informado");
        }
    }
}
----
[source, java]
----
package noventaenovediasdejava.dia08;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class JogoJokenpoTest {
    @Test
    void naoDevePermitirInstanciacao() {
        Assertions
            .assertThrows(
                IllegalArgumentException.class,
                () -> new JogoJokenpo(null, null),
                "não deve ser permitido a instanciação do jogo sem jogadores"
            );
        Assertions
            .assertThrows(
                IllegalArgumentException.class,
                () -> new JogoJokenpo(new JogadorJokenpo() {
                }, null),
                "não deve ser permitido a instanciação do jogo só com o jogador 01"
            );
        Assertions
            .assertThrows(
                IllegalArgumentException.class,
                () -> new JogoJokenpo(
                    null,
                    new JogadorJokenpo() {
                    }
                ),
                "não deve ser permitido a instanciação do jogo só com o jogador 02"
            );
    }
}
----
== Dia 09 - Jokenpô em Java - Pedra, Papel ou Tesoura?

[source,java]
----
package noventaenovediasdejava.dia09;

public enum MovimentoJokenpo {
    PEDRA {
        @Override
        public boolean ganhaDe(final MovimentoJokenpo movimento) {
            return TESOURA.equals(movimento);
        }
    },
    PAPEL {
        @Override
        public boolean ganhaDe(final MovimentoJokenpo movimento) {
            return switch (movimento) {
                case PEDRA -> true;
                default -> false;
            };
        }
    },
    TESOURA {
        @Override
        public boolean ganhaDe(final MovimentoJokenpo movimento) {
            return PAPEL.equals(movimento);
        }
    };

    public abstract boolean ganhaDe(final MovimentoJokenpo movimento);
}
----
[source, java]
----
package noventaenovediasdejava.dia09;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

class MovimentoJokenpoTest {
    @Test
    void testeDeEstrutura() {
        final var values = MovimentoJokenpo.values();
        Assertions.assertEquals(
            3,
            values.length,
            "Só deve ter 3 tipos de movimentos Jokenpô"
        );
        Assertions.assertEquals("PEDRA", values[0].name());
        Assertions.assertEquals("PAPEL", values[1].name());
        Assertions.assertEquals("TESOURA", values[2].name());
    }

    @Test
    void testarComportamento() {
        Assertions.assertEquals(true,
                                MovimentoJokenpo.PAPEL
                                    .ganhaDe(MovimentoJokenpo.PEDRA));
        Assertions.assertEquals(true,
                                MovimentoJokenpo.PEDRA
                                    .ganhaDe(MovimentoJokenpo.TESOURA));
        Assertions.assertEquals(true,
                                MovimentoJokenpo.TESOURA
                                    .ganhaDe(MovimentoJokenpo.PAPEL));
    }
}
----
== Dia 10 -  Jokenpô em Java - Quem vencerá?

[source,java]
----
package noventaenovediasdejava.dia10;

@FunctionalInterface
public interface JogadorJokenpo {
    MovimentoJokenpo jogar();
}
----
[source,java]
----
package noventaenovediasdejava.dia10;

public record JogadaJokenpo(
    boolean acabouEmpatada,
    JogadorJokenpo vencedor,
    JogadorJokenpo perdedor
) {
}
----
[source,java]
----
package noventaenovediasdejava.dia10;

public class JogoJokenpo {
    private final JogadorJokenpo jogador01;
    private final JogadorJokenpo jogador02;

    public JogoJokenpo(
        final JogadorJokenpo jogador01,
        final JogadorJokenpo jogador02
    ) {
        if (jogador01 == null && jogador02 == null) {
            throw new IllegalArgumentException("jogadores não informados");
        }
        if (jogador01 != null && jogador02 == null) {
            throw new IllegalArgumentException("jogador 02 não informado");
        }
        if (jogador01 == null && jogador02 != null) {
            throw new IllegalArgumentException("jogador 01 não informado");
        }
        this.jogador01 = jogador01;
        this.jogador02 = jogador02;
    }

    public JogadaJokenpo executarJogada() {
        MovimentoJokenpo movimentoJokenpo01 = this.jogador01.jogar();
        MovimentoJokenpo movimentoJokenpo02 = this.jogador02.jogar();
        if (movimentoJokenpo01.ganhaDe(movimentoJokenpo02)) {
            return new JogadaJokenpo(false, jogador01, jogador02);
        }
        if (movimentoJokenpo02.ganhaDe(movimentoJokenpo01)) {
            return new JogadaJokenpo(false, jogador02, jogador01);
        }
        return new JogadaJokenpo(true, null, null);
    }
}
----
[source, java]
----
package noventaenovediasdejava.dia10;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class JogoJokenpoTest {
    @Test
    void naoDevePermitirInstanciacao() {
        final JogadorJokenpo jogador = () -> null;
        Assertions
            .assertThrows(
                IllegalArgumentException.class,
                () -> new JogoJokenpo(null, null),
                "não deve ser permitido a instanciação do jogo sem jogadores"
            );
        Assertions
            .assertThrows(
                IllegalArgumentException.class,
                () -> new JogoJokenpo(jogador, null),
                "não deve ser permitido a instanciação do jogo só com o jogador 01"
            );
        Assertions
            .assertThrows(
                IllegalArgumentException.class,
                () -> new JogoJokenpo(
                    null, jogador
                ),
                "não deve ser permitido a instanciação do jogo só com o jogador 02"
            );
    }

    @Test
    void testeExecutarJogada() {
        JogadorJokenpo pietro = () -> MovimentoJokenpo.PEDRA;
        JogadorJokenpo max = () -> MovimentoJokenpo.TESOURA;
        JogoJokenpo jogo = Assertions
            .assertDoesNotThrow(
                () -> new JogoJokenpo(pietro, max),
                "deveria permitir a criação do Jogo"
            );
        JogadaJokenpo jogada = jogo.executarJogada();
        Assertions.assertEquals(
            false,
            jogada.acabouEmpatada()
        );
        Assertions.assertEquals(pietro, jogada.vencedor());
        Assertions.assertEquals(max, jogada.perdedor());
    }
}
----
